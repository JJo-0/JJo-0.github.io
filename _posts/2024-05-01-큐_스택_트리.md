---
title: "í_ìŠ¤íƒ_íŠ¸ë¦¬ ì˜ˆì‹œ ë° ì„¤ëª…"
date: 2024-05-01 18:24:00
categories:
  - ì •ë¦¬
  - ì†Œí”„íŠ¸ì›¨ì–´
  - AMR
tags:
  - Docker
  - ubuntu
toc: true
toc_sticky: true
toc_label: "í_ìŠ¤íƒ_íŠ¸ë¦¬"
---

# íŠ¸ë¦¬ ê´€ë ¨ ì„¤ëª… 
---
**ê°œë… ë§í¬ ì°¸ì¡°** [ìë£Œêµ¬ì¡°(Data Structure)ìŠ¤íƒ/í/ê·¸ë˜í”„/íŠ¸ë¦¬](https://velog.io/@j_jhwww/TIL%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0Data-Structure-%EC%8A%A4%ED%83%9D%ED%81%90%EA%B7%B8%EB%9E%98%ED%94%84%ED%8A%B8%EB%A6%AC)    
**ì´ì§„ íŠ¸ë¦¬ ì°¸ì¡°** [íŠ¸ë¦¬ì™€_ì´ì§„_íŠ¸ë¦¬_ê°œë…_ì •ë¦¬](https://80000coding.oopy.io/a9f714f9-4f76-4592-8c38-51913c3a885f)    


# ìë£Œêµ¬ì¡° ì‹¤ìŠµ ê³¼ì œ ë¸”ë¡ë³„ í•´ì„¤   
---
### ğŸ“š ë¬¸ì œ   

##### ë¬¸ì œ 1) ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ ë§Œë“¤ê³  ê²€ìƒ‰í•˜ê¸°
í•™ìƒì˜ í•™ë²ˆê³¼ ì´ë¦„ í•­ëª©ì„ ê°€ì§€ëŠ” í•™ìƒì •ë³´ë¥¼ ì´ì§„ ê²€ìƒ‰íŠ¸ë¦¬ë¡œ ë§Œë“¤ì–´ ì €ì¥í•˜ê³ ì í•œë‹¤.    
ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ì—ì„œ í•™ìƒì˜ í•™ë²ˆ í•­ëª©ì„ í‚¤ë¡œ í™œìš©í•˜ì—¬ ì´ì§„ ê²€ìƒ‰íŠ¸ë¦¬ë¥¼ ë§Œë“ ë‹¤     
(í•™ë²ˆì€ ì¤‘ë³µ ë˜ì§€ ì•Šìœ¼ë©°, ë§Œì•½ ì¤‘ë³µëœ í•™ë²ˆìœ¼ë¡œ ì €ì¥í•  ê²½ìš° ë‘ ë²ˆì§¸ ì €ì¥ ëª…ë ¹ì€ ë¬´ì‹œë¨).    
ë§Œë“¤ì–´ì§„ ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ì—ì„œ 
1) ë…¸ë“œìˆ˜, 
2) ë‹¨ë§ ë…¸ë“œ ìˆ˜, 
3) íŠ¸ë¦¬ì˜ ë†’ì´
4) ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ((ë¶€ëª¨ë…¸ë“œ)->[ìì‹ë…¸ë“œ]ê´€ê³„ í‘œì‹œ), 
5) ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ì¤‘ìœ„ ìˆœíšŒ, 
6) ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ì—ì„œ ê²€ìƒ‰, 
7) ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ì—ì„œ ë…¸ë“œ ì‚­ì œ, 
8) ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ ì „ì²´ ì‚­ì œë¥¼ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•˜ì‹œì˜¤. 
      
ì´ì§„ ê²€ìƒ‰ íŠ¸ë¦¬ë¥¼ ìœ„í•œ ìë£Œ êµ¬ì¡°ì™€ main() í•¨ìˆ˜ ë‚´ì˜ ì½”ë“œë¥¼ í™œìš©í•˜ì—¬ ì•„ë˜ ì‹¤í–‰ ì˜ˆì˜ ê²°ê³¼ì™€ ê°™ì´ ë³´ì—¬ì¤„ ìˆ˜ ìˆë„ë¡ í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.
```c
//ì£¼ì–´ì§„ ì½”ë“œ ë° ë¬¸ì œ
typedef struct ELEMENT {
	int id_num;
	char name[10];
}element;

typedef struct TreeNode {
	element std;
	struct TreeNode* left, * right;
} TreeNode;

int main(void) {
	TreeNode* root = NULL; TreeNode* tmp = NULL; element item;
	item.id_num = 2021006; strcpy(item.name, "name6"); root = insert_node(root, item);
	item.id_num = 2021001; strcpy(item.name, "name1"); root = insert_node(root, item);
	item.id_num = 2021009; strcpy(item.name, "name9"); root = insert_node(root, item);
	item.id_num = 2021007; strcpy(item.name, "name7"); root = insert_node(root, item);
	item.id_num = 2021003; strcpy(item.name, "name3"); root = insert_node(root, item);
	item.id_num = 2021002; strcpy(item.name, "name2"); root = insert_node(root, item);
	item.id_num = 2021005; strcpy(item.name, "name5"); root = insert_node(root, item);
	item.id_num = 2021004; strcpy(item.name, "name4"); root = insert_node(root, item);
	item.id_num = 2021008; strcpy(item.name, "name8"); root = insert_node(root, item);
	item.id_num = 2021010; strcpy(item.name, "name10"); root = insert_node(root, item);
	printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ë…¸ë“œ ìˆ˜, leafë…¸ë“œ ìˆ˜, ë†’ì´ êµ¬í•˜ê¸°\n");
	printf("ë…¸ë“œ ìˆ˜ = %d \nleaf ë…¸ë“œ ìˆ˜ = %d \në†’ì´ = %d \n\n", get_node_count(root), get_leaf_count(root), get_height(root));
	printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ ê²°ê³¼\n"); 
	level_order(root);

	printf("\n\n");
	printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ \n");
	inorder(root);

	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021010 ê²€ìƒ‰\n");
	tmp = search(root, 2021010);
	if (tmp != NULL)
		printf("ê²€ìƒ‰ ì„±ê³µ : í•™ë²ˆ %d, ì´ë¦„ %s \n", tmp->std.id_num, tmp->std.name);
	else
		printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ê²€ìƒ‰ í•™ìƒì„ ë°œê²¬ëª»í•¨ \n");
	printf("\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021006 ì‚­ì œ\n");
	delete_node(&root, 2021006);
	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021006 ê²€ìƒ‰\n");
	tmp = search(root, 2021006);
	if (tmp != NULL)
		printf("ê²€ìƒ‰ ì„±ê³µ : í•™ë²ˆ %d, ì´ë¦„ %s \n", tmp->std.id_num, tmp->std.name);
	else
		printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ê²€ìƒ‰ í•™ìƒì„ ë°œê²¬ëª»í•¨ \n");

	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ \n"); inorder(root);
	printf("\n\n");
	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì „ì²´ ì‚­ì œ \n"); root = delete_tree(root);
	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ ê²°ê³¼\n"); level_order(root);
	printf("\n\n");

	return 0;
}
```
    
###### ê²°ê³¼ ì˜ˆì‹œ
```bash 
ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ë…¸ë“œ ìˆ˜, leafë…¸ë“œ ìˆ˜, ë†’ì´ êµ¬í•˜ê¸°
ë…¸ë“œ ìˆ˜ = 10
leaf ë…¸ë“œ ìˆ˜ = 4
ë†’ì´ = 5

ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ ê²°ê³¼
Level 1 : [2021006]
Level 2 : (2021006)->[2021001] (2021006)->[2021009]
Level 3 : (2021001)->[2021003] (2021009)->[2021007] (2021009)->[2021010]
Level 4 : (2021003)->[2021002] (2021003)->[2021005] (2021007)->[2021008]
Level 5 : (2021005)->[2021004]


ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼
[2021001] [2021002] [2021003] [2021004] [2021005] [2021006] [2021007] [2021008] [2021009] [2021010]

ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021010 ê²€ìƒ‰
ê²€ìƒ‰ ì„±ê³µ : í•™ë²ˆ 2021010, ì´ë¦„ name10

ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021006 ì‚­ì œ


ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021006 ê²€ìƒ‰
ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ê²€ìƒ‰ í•™ìƒì„ ë°œê²¬ëª»í•¨


ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼
[2021001] [2021002] [2021003] [2021004] [2021005] [2021007] [2021008] [2021009] [2021010]



ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì „ì²´ ì‚­ì œ
[2021002] [2021004] [2021005] [2021003] [2021001] [2021008] [2021010] [2021009] [2021007]

ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ ê²°ê³¼
ê³µë°± íŠ¸ë¦¬ì…ë‹ˆë‹¤.

```

---
### ğŸ‘¨ğŸ»â€ğŸ’» í•´ê²° ì½”ë“œ
> ì•„ë§ˆë„ ê¹¨ë—í•˜ê²Œ ë˜ì–´ì§„ ì½”ë“œëŠ” ì•„ë‹ˆë‹¤. 
> ë‚˜ì¤‘ì— ë³´ë©´ ì—‰í„°ë¦¬ ì½”ë“œì´ê² ì§€ë§Œ, ê·¸ëŸ¼ì—ë„ ë‚¨ê¸´ë‹¤.   

### ì „ì²´ ì½”ë“œ

```c
//binary Tree ì„¤ëª…
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct ELEMENT {
	int id_num;
	char name[10];
}element;

typedef struct TreeNode {
	element std;
	struct TreeNode* left, * right, * parent;
} TreeNode;

int max(int a, int b) {
	return (a > b) ? a : b;
}

TreeNode* new_node(element item) {
	TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));
	newNode->std.id_num = item.id_num;
	strcpy(newNode->std.name, item.name);
	newNode->left = newNode->right = newNode->parent = NULL;
	return newNode;
}

TreeNode* insert_node(TreeNode* node, element item) {
    if (node == NULL) {
        TreeNode* newNode = new_node(item);
        return newNode;
    }
	if (item.id_num < node->std.id_num) {
		node->left = insert_node(node->left, item);
		node->left->parent = node;  // ë¶€ëª¨ ë…¸ë“œ ì„¤ì •
	}
	else if (item.id_num > node->std.id_num) {
		node->right = insert_node(node->right, item);
		node->right->parent = node;  // ë¶€ëª¨ ë…¸ë“œ ì„¤ì •
	}

    return node;
}

int get_node_count(TreeNode* node) {
	int count = 0;
	if (node != NULL) {
		count = 1 + get_node_count(node->left) + get_node_count(node->right);
	}
	return count;
}
int get_leaf_count(TreeNode* node) {
	int count = 0;
	if (node != NULL) {
		if (node->left == NULL && node->right == NULL) return 1;
		else {
			count = get_leaf_count(node->left) + get_leaf_count(node->right);
		}
	}
	return count;
}
int get_height(TreeNode* node) {
	int height = 0;
	if (node != NULL) {
		height = 1 + max(get_height(node->left), get_height(node->right));
	}
	return height;
}

void inorder(TreeNode* node) {
	if (node) {
		inorder(node->left);
		printf("[%d] ", node->std.id_num);
		inorder(node->right);
	}
}

TreeNode* search(TreeNode* node, int id_num) {
	if (node == NULL) return NULL;
	if (id_num == node->std.id_num) return node;
	else if (id_num < node->std.id_num)
		return search(node->left, id_num);
	else
		return search(node->right, id_num);

}

TreeNode* min_value_node(TreeNode* node) {
	TreeNode* current = node;

	while (current && current->left != NULL) {
		current = current->left;
	}
	return current;
}

void delete_node(TreeNode** rootRef, int id_num) {
	TreeNode* root = *rootRef;
	if (root == NULL) return;

	if (id_num < root->std.id_num)
		delete_node(&(root->left), id_num);
	else if (id_num > root->std.id_num)
		delete_node(&(root->right), id_num);
	else { // key is same
		if (root->left == NULL) {
			TreeNode* temp = root->right;
			free(root);
			*rootRef = temp;
		}
		else if (root->right == NULL) {
			TreeNode* temp = root->left;
			free(root);
			*rootRef = temp;
		}
		else {
			TreeNode* temp = min_value_node(root->right);
			root->std.id_num = temp->std.id_num;
			strcpy(root->std.name, temp->std.name);
			delete_node(&(root->right), temp->std.id_num);
		}
	}
}

TreeNode* delete_tree(TreeNode* root) {
	if (root == NULL) return NULL;

	root->left = delete_tree(root->left);
	root->right = delete_tree(root->right);
	printf("[%d] ",root->std.id_num);
	free(root);
	return NULL;
}

// í ë…¸ë“œ ì •ì˜
typedef struct QueueNode {
	TreeNode* treeNode;
	struct QueueNode* next;
} QueueNode;

// í ì •ì˜
typedef struct {
	QueueNode* front;
	QueueNode* rear;
	int count;
} Queue;

// í ì´ˆê¸°í™”
void initQueue(Queue* q) {
	q->front = q->rear = NULL;
	q->count = 0;
}

// íê°€ ë¹„ì—ˆëŠ”ì§€ í™•ì¸
int isEmpty(Queue* q) {
	return q->count == 0;
}

// íì— ë…¸ë“œ ì¶”ê°€
void enqueue(Queue* q, TreeNode* node) {
	QueueNode* newNode = (QueueNode*)malloc(sizeof(QueueNode));
	newNode->treeNode = node;
	newNode->next = NULL;
	if (isEmpty(q)) {
		q->front = q->rear = newNode;
	}
	else {
		q->rear->next = newNode;
		q->rear = newNode;
	}
	q->count++;
}

// íì—ì„œ ë…¸ë“œ ì œê±°
TreeNode* dequeue(Queue* q) {
	if (isEmpty(q)) return NULL;
	QueueNode* temp = q->front;
	TreeNode* result = temp->treeNode;
	q->front = q->front->next;
	if (q->front == NULL) q->rear = NULL;
	free(temp);
	q->count--;
	return result;
}

// ë ˆë²¨ ìˆœíšŒ êµ¬í˜„
void level_order(TreeNode* root) {
	if (root == NULL) {
		printf("ê³µë°± íŠ¸ë¦¬ì…ë‹ˆë‹¤.\n");
		return;
	}

	Queue q;
	initQueue(&q);
	enqueue(&q, root);

	int level = 0;

	while (!isEmpty(&q)) {
		int levelCount = q.count; // í˜„ì¬ ë ˆë²¨ì˜ ë…¸ë“œ ìˆ˜
		printf("Level %d : ", ++level);

		while (levelCount > 0) {
			TreeNode* current = dequeue(&q);

			// í˜„ì¬ ë…¸ë“œ ì¶œë ¥
			if (current->parent != NULL) printf("(%d)->", current->parent->std.id_num);
			printf("[%d] ", current->std.id_num);

			if (current->left != NULL) enqueue(&q, current->left);
			if (current->right != NULL) enqueue(&q, current->right);

			levelCount--;
		}

		printf("\n");
	}
}

int main(void) {
	TreeNode* root = NULL; TreeNode* tmp = NULL; element item;
	item.id_num = 2021006; strcpy(item.name, "name6"); root = insert_node(root, item);
	item.id_num = 2021001; strcpy(item.name, "name1"); root = insert_node(root, item);
	item.id_num = 2021009; strcpy(item.name, "name9"); root = insert_node(root, item);
	item.id_num = 2021007; strcpy(item.name, "name7"); root = insert_node(root, item);
	item.id_num = 2021003; strcpy(item.name, "name3"); root = insert_node(root, item);
	item.id_num = 2021002; strcpy(item.name, "name2"); root = insert_node(root, item);
	item.id_num = 2021005; strcpy(item.name, "name5"); root = insert_node(root, item);
	item.id_num = 2021004; strcpy(item.name, "name4"); root = insert_node(root, item);
	item.id_num = 2021008; strcpy(item.name, "name8"); root = insert_node(root, item);
	item.id_num = 2021010; strcpy(item.name, "name10"); root = insert_node(root, item);
	printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì˜ ë…¸ë“œ ìˆ˜, leafë…¸ë“œ ìˆ˜, ë†’ì´ êµ¬í•˜ê¸°\n");
	printf("ë…¸ë“œ ìˆ˜ = %d \nleaf ë…¸ë“œ ìˆ˜ = %d \në†’ì´ = %d \n\n", get_node_count(root), get_leaf_count(root), get_height(root));
	printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ ê²°ê³¼\n"); 
	level_order(root);
	
	printf("\n\n");
	printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ \n");
	inorder(root);

	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021010 ê²€ìƒ‰\n");
	tmp = search(root, 2021010);
	if (tmp != NULL)
		printf("ê²€ìƒ‰ ì„±ê³µ : í•™ë²ˆ %d, ì´ë¦„ %s \n", tmp->std.id_num, tmp->std.name);
	else
		printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ê²€ìƒ‰ í•™ìƒì„ ë°œê²¬ëª»í•¨ \n");
	printf("\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021006 ì‚­ì œ\n");
	delete_node(&root, 2021006);
	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ 2021006 ê²€ìƒ‰\n");
	tmp = search(root, 2021006);
	if (tmp != NULL)
		printf("ê²€ìƒ‰ ì„±ê³µ : í•™ë²ˆ %d, ì´ë¦„ %s \n", tmp->std.id_num, tmp->std.name);
	else
		printf("ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ì—ì„œ ê²€ìƒ‰ í•™ìƒì„ ë°œê²¬ëª»í•¨ \n");

	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì¤‘ìœ„ ìˆœíšŒ ê²°ê³¼ \n"); inorder(root);
	printf("\n\n");
	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ì „ì²´ ì‚­ì œ \n"); root = delete_tree(root);
	printf("\n\nì´ì§„ íƒìƒ‰ íŠ¸ë¦¬ ë ˆë²¨ íƒìƒ‰ ìˆœíšŒ ê²°ê³¼\n"); level_order(root);
	printf("\n\n");

	return 0;
}
```
